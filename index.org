:PROPERTIES:
:ID:       a7079bca-3f51-474f-8951-d171b4c137ba
:END:
#+Title: Introduction to Scripting for Scientists
#+Subtitle: A Very Brief Guide for the Intrepid Labratorian
#+Author: Delta Alexander Sharp
#+Email: nalisarc@gmail.com
#+STARTUP: beamer
* Export Setting                                                   :noexport:
#+DESCRIPTION: 
#+KEYWORDS: 
#+LANGUAGE:  en
#+OPTIONS:   H:2 num:t toc:t \n:nil @:t ::t |:t ^:t -:t f:t *:t <:t
#+OPTIONS:   TeX:t LaTeX:t skip:nil d:nil todo:t pri:nil tags:not-in-toc
#+INFOJS_OPT: view:nil toc:nil ltoc:t mouse:underline buttons:0 path:https://orgmode.org/org-info.js
#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: noexport
#+HTML_LINK_UP:
#+HTML_LINK_HOME:
#+beamer_theme: Madrid
#+LATEX_HEADER: \usepackage{tikz}
#+COLUMNS: %40ITEM %10BEAMER_env(Env) %9BEAMER_envargs(Env Args) %4BEAMER_col(Col) %10BEAMER_extra(Extra)



 
* End block                                                        :noexport:
copy this into a frame to end a block. 
#+begin_src org
,*** End of block                                               :B_ignoreheading:
:PROPERTIES:
:BEAMER_env: ignoreheading
:END:
#+end_src

* Setup                                                            :noexport:
#+begin_src ipython :session i2sc :cache yes 
%matplotlib inline
import matplotlib.pyplot as plt
import numpy as np
import random 
#+end_src

#+RESULTS[022e926dd1397aec38b400784929abee7283931b]:
: # Out[34]:


* Exporter                                                         :noexport:

Replace the exporter with the desired one and then just export as latex-beamer~
#+call: beamer-export()


** Beamer Setting                                                  :noexport:
Run this block to export as standard beamer presentation
#+name: beamer-export
#+begin_src org
,#+LaTeX_CLASS: beamer
,#+LaTeX_CLASS_OPTIONS: [allowframebreaks]
,#+OPTIONS: H:2
#+end_src

** Handout Setting                                                 :noexport:
Run this block to theoretically export it with my extra notes but no animation.
#+name: handout-export
#+begin_src org
,#+OPTIONS: H:2
,#+LaTeX_CLASS: beamer
,#+LaTeX_CLASS_OPTIONS: [handout]
,#+LATEX_HEADER: %%% For handouts with lots of extra notes
,#+LATEX_HEADER: \documentclass[handout]{beamer}
,#+LATEX_HEADER: \usepackage{pgfpages}
,#+LATEX_HEADER: \pgfpagesuselayout{2 on 1}[a4paper,border shrink=5mm] % could also use letterpaper
,#+LATEX_HEADER: \setbeameroption{show notes on second screen=bottom} % Beamer manual, section 19.3
,#+LATEX_HEADER: %%%
,#+LATEX_HEADER: 
,#+LATEX_HEADER: \setbeamertemplate{note page}[plain] % Beamer manual, section 19.1
,#+LATEX_HEADER: \newlength{\parskipbackup}
,#+LATEX_HEADER: \setlength{\parskipbackup}{\parskip}
,#+LATEX_HEADER: \newlength{\parindentbackup}
,#+LATEX_HEADER: \setlength{\parindentbackup}{\parindent}
,#+LATEX_HEADER: \newcommand{\baselinestretchbackup}{\baselinestretch}
,#+LATEX_HEADER: \usetemplatenote{\rmfamily \scriptsize%
,#+LATEX_HEADER:   \setlength{\parindent}{1em} \setlength{\parskip}{1ex}%
,#+LATEX_HEADER:   \renewcommand{\baselinestretch}{1}%
,#+LATEX_HEADER:   \noindent \insertnote%
,#+LATEX_HEADER: 
,#+LATEX_HEADER:   \setlength{\parskip}{\parskipbackup}%
,#+LATEX_HEADER:   \setlength{\parindent}{\parindentbackup}%
,#+LATEX_HEADER:   \renewcommand{\baselinestretch}{\baselinestretchbackup}%
,#+LATEX_HEADER: }
#+end_src

** Latex Article                                                   :noexport:
** Blog Post
* Introduction
** Who am I?
My name Is Delta Alexander Smith (they/them.)\\
Mad scientist extraordinaire. 
*** Experience
 - I've been programming since early 2014, specializing in:
   - Data Science
   - Embedded Devices
   - Reproducable Research
 - I've written multiple pieces of internal business software which have increased productivity.



** Discussion Expectations
For the sake of time, we need to establish a scope for our discussion.
*** What we'll be covering                                            :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.6
:END:
 - What is programming (scripting)
 - How computers represent things. 
 - How scripting can make your work more reproducable.
 - Why introducing scripts can make your work easier as a scientist.
*** What we won't                                                     :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.4
:END:
 - Artificial intelligence (AI)
 - Best practices
 - Details

** On Jargon

*** Block                                                   :B_ignoreheading:
:PROPERTIES:
:BEAMER_env: ignoreheading
:END:
Unfortuately as in every domain of science, Computer Science  is racked full of jargon.

*** Examples of Jagon                                             :B_example:
:PROPERTIES:
:BEAMER_ENV: exampleblock
:END:
 - strings, floats, dictionaries
 - sequences, maps, iterators
 - functions, class, objects
 - paths, api(s), 

*** endblock                                                :B_ignoreheading:
:PROPERTIES:
:BEAMER_env: ignoreheading
:END:
Most of these terms are confusing to newcomers.
But it is vital to not get too hung up on the terminiology.

** What Is Scripting?
Programmers love to make up names for things:
*** Program                                                    :B_definition:
:PROPERTIES:
:BEAMER_env: definition
:END:
A set of instructions interpreted by a computer.


 
*** Script                                                     :B_definition:
:PROPERTIES:
:BEAMER_env: definition
:END:
A program that typically:
 - is specialized to a task
 - has minimal user interaction
 - can be called from the commandline or other scripts

   
 
*** The commandline and shells                                       :B_note:
:PROPERTIES:
:BEAMER_env: note
:END:
Most applications do not need a graphical user interface (GUI).
Instead they are called using the shell.

The shell (sometimes called the terminal or commandline) are a textual interface for a computer.

You type in a command(stdin)  and the output is written to the screen (stdout).

Errors (stderr) are usually written in different colors.

Commands consist of a program to run, followed by arguments such as flags, or input and output files.

Programs can be "piped" into eachother allowing for very powerful systems made from standardized parts.

The output of programs can be written to specific files allowing for logs.

The shell is often viewed as intimedating, but it is arguably the most flexible
way to interact with a computer.

The shell can run over serial connections allowing for so called "headless machines."

**** Example Shells
 - Powershell,
 - Bash,
 - Zsh



**** Example Unix

**** Example Windows

*** Shell and the Kernel                                             :B_note:
:PROPERTIES:
:BEAMER_env: note
:END:

A computer operating system (OS) is a very complex engine that
make using a computer pleasant.

The metaphor used to describe the different parts of an operating system
is that of a grain or seed.

The shell is the outermost part the user interacts with,
beneth is the kernel which the seed is built out from.

When we need to interact with a computer, rather than trying to directly
manipulate the kernel directly which is messy and fragile we can work with
a standardized interface.


* Computers are a revolutionary tool

** Computers can handle Massive data sets 

*** How big is the human genome?                            :B_ignoreheading:
:PROPERTIES:
:BEAMER_env: ignoreheading
:END:
The human genome is made up of 3.2 billion base pairs.

*** Exercise: How big is that?                                      :B_block:
:PROPERTIES:
:BEAMER_env: block
:END:
How long would it take someone to transcribe one, at 60 wph, taking 8 hour days?

**** Answers                                                :B_ignoreheading:
:PROPERTIES:
:BEAMER_env: ignoreheading
:END:

 - A. 1 year
 - B. 100 years
 - C. 50 years
 - D. 30 years

*** Rapid Sequencing                                         :B_exampleblock:
:PROPERTIES:
:BEAMER_env: exampleblock
:END:
Stanford scientists set a record in 2022 by sequencing a whole human
genome in just over 5 hours!


** Alright, I'll Byte
First some definitions:
*** Bit                                                  :B_definition:
:PROPERTIES:
:BEAMER_env: definition
:END:
A bit is an object,that can be in one of two states.
 - on or off
 - 1 or 0
 - True or False
*** Byte                                                       :B_definition:
:PROPERTIES:
:BEAMER_env: definition
:END:
A byte is a sequence of 8 bits.
** Computers represent things using bytes
By carefully arranging larger and larger sequences of bytes you can represent
virtually anything.
*** Abstractions
In practice, it isn't generally worth it to think of data as a blob of binary.
Computer programs take these blobs and decode them into a format people can use.
**** Examples
 - audio
 - video
 - images
 - documents
 - achieves
** Scales of Information
As these bytearrays build up in size they can express more and more
complex ideas.
*** Common prefixes                                           :B_block:BMCOL:
:PROPERTIES:
:BEAMER_env: block
:BEAMER_col: 0.4
:END:


| Prefix    | number of bits |
|-----------+----------------|
|           |              1 |
|-----------+----------------|
| Kilo (kb) |           1e+3 |
|-----------+----------------|
| Mega (mb) |           1e+6 |
|-----------+----------------|
| Giga (gb) |           1e+9 |
|-----------+----------------|
| Tera (tb) |          1e+12 |

*** Examples of files sizes                            :B_exampleblock:BMCOL:
:PROPERTIES:
:BEAMER_env: exampleblock
:BEAMER_col: 0.6
:END:

| File type    | typical size   |
|--------------+----------------|
| Images       | ~2kb - 1000kb  |
|--------------+----------------|
| Documents    | ~4kb - 5mb     |
|--------------+----------------|
| Music        | ~3mb - 4mb     |
|--------------+----------------|
| Video        | ~4gb - 20gb    |
|--------------+----------------|
| Genomic Data | ~100mb - 100tb |

*** Computers don't understand data!                                :B_block:
:PROPERTIES:
:BEAMER_env: block
:END:
Computers only /see/ and work on these blobs.\\
The meaning comes from people.

** Computers are precise and repeatable    
*** Computers designed to be deterministic                          :B_block:
:PROPERTIES:
:BEAMER_env: block
:END:
 - They do exactly what you tell them
 - As many times as you need
 - Whenever you want them to

*** Ideal use cases for computers                                   :B_block:
:PROPERTIES:
:BEAMER_env: block
:END:
 - Continous monitoring of sensor data
 - Alerting when readings are out of spec
 - Recording experimental data as it happens
 - Precise timing at super human speeds
 - Calculation and Validation
   



** Computers have Consequences
*** Computers are complex systems                                   :B_block:
:PROPERTIES:
:BEAMER_env: block
:END:
Unfortuantely real computers run on physical machines.\\
Which makes them subject to intermittent and unpredictable errors.

#+DOWNLOADED: screenshot @ 2023-04-13 17:51:38
#+caption: @carrickdb@infosec.exchange
[[file:Computers_are_a_revolutionary_tool/2023-04-13_17-51-38_screenshot.png]]

*** Virtual Machines                                                 :B_note:
:PROPERTIES:
:BEAMER_env: note
:END:
Computers can actually simulate other computers! This process is usually
called virtualization or emulation depending on the context.
*** Virtualization lets you share consistently                       :B_note:
:PROPERTIES:
:BEAMER_env: note
:END:
One major use for virtualization is making environments that behave
the same regardless of the host machine.

However this is a non trivial process which is beyond the scope of
this discussion.
** Computers are fallable!                           
 Computers will quickly perform badly formed or malicious commands!
 - Computers can and *will* destroy themselves when ordered.
 - Bad code can and *will* be exploited.
 - Computer networks scale this damage up *exponentially*

*** Malware                                                          :B_note:
:PROPERTIES:
:BEAMER_env: note
:END:
Just as chemistry can produce wonderful medicines, and terrible toxins;
computers can be used for evil. 
**** What is it?
Malware is code that does something harmful to you, your machine, or anything
connected to those machines.
**** Why is it made?
Many forms of malware were made accidentally or as a proof of concept.
However there are some malicous actors that do so for nefarious reasons
like identity theft, or espionage.


****  General advice                                         :B_exampleblock:
:PROPERTIES:
:BEAMER_env: exampleblock
:END:
That being said, *every* tool can be misused.
 - Don't use personal computers for work.
 - Don't use work computers for personal reasons.
 - Don't plug nonsecure devices into secure one.
 - If it doesn't need a network connection; don't connect it.

*** On Hackers                                                       :B_note:
:PROPERTIES:
:BEAMER_env: note
:END:
A hacker is a person who is interested in a topic (typically computers.)

Hackers approach problems from a different direction than many, trying stuff and seeing what happens.
Some record what they find and share it with their peers.

In other words, a scientist is a type of hacker.

Confusing a hacker with a cyber-criminal is like mistaking a clandestine chemist with
a pharmacist. 
** Data Visualization enables better communication
Computers are able to render graphics faster and more accurately than people
which enables a multitude of opportunities.
*** Good data visualization is vital!                             :B_theorem:
:PROPERTIES:
:BEAMER_env: theorem
:END:
Good data visualization helps people understand very complex datasets
and communicate those ideas.
*** Goodexample
*** Badexample
** General Datavisualization Tips
 - When in doubt, Bar graph it out!
 - Use a combination of colors and symbols
   - does it make senses in black/white?
 - Clear titles, and legends are your friends!


** Computers and people are good at different things!
It can be tempting to try and use computers for everything.
However, this is a naive approach.

*** People aren't computers*                                      :B_theorem:
:PROPERTIES:
:BEAMER_env: theorem
:END:
People and computers are suited for different tasks:
**** Computer Problems                                                :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.5
:END:
 - Data storage and retrevial
 - Search engines
 - Continous sensor monitoring
 - Ultra high speed signal processing
 - Automatable tasks
**** People Problems                                                  :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.5
:END:
 - General problem solving
 - Complex analysis
 - Non standard environments
 - Fuzzy problems
 - Creative tasks
*** Origin of the Word: Computer                                     :B_note:
:PROPERTIES:
:BEAMER_env: note
:END:
The word computer originally referred to a profession held by primarily women.

Human Computers would take a set of inputs, and perform a set of *computations* (a program)
producing a set of output.

These people were vital for many fields ranging from:
 - business
 - academia
 - military
 - engineering

However these people were often dismissed as menial labors despite
the expertise required.




*** On Computable and Uncomputable Problems                          :B_note:
:PROPERTIES:
:BEAMER_env: note
:END:
There different types of problems that can be solved in what is called polynomial time (P type problems)
and ones that can only be solved in non-polynomial time (NP type problems).

Computers can only really solve P problems.
However they can "brute force" NP problems by systematically trying
countless inputs.

People can solve NP problems but they can't really explain how.
Many puzzle games like Sudoku are NP problems.

For further reading, look into the halting problem.

** Scripting allows you to redo you work easily             
Reusing code can let you standardize and automate your workflow.

*** Pasteurization Report Generator                               :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
A previous employeer pasteurized breastmilk for at-risk newborns.
PRG was built to take the temperature readings for each batch and create a
customized report.

This report was used to verify if a batch met all critical points:
 - Got hot enough
 - For long enough
 - Cooled for storage

PRG took a multi-hour task collapsing it into a managable one.

*** Block                                                   :B_ignoreheading:
:PROPERTIES:
:BEAMER_env: ignoreheading
:END:
   

** Version Control 


*** People Problems
 - Overwriting each other's work
 - Stale and out-of-date copies
 - Breaking changes
 - Crediting contributions
*** VC to the rescue!
 - Track changes
 - Ensures changes are current
 - Revert broken commits
 - Access control, and logging

** In short:
Scripting makes your work more robust and reproducible!
*** Science is based on reproducibility!
How do you find out how the world works?
 - Observe:
   What are you interested in learning?
 - Hypothesize:
   What do you think is happening?
 - Test:
   Cast your ideas to the crucible! 
 - Document and Share:
   Show your work!

*** block                                                   :B_ignoreheading:
:PROPERTIES:
:BEAMER_env: ignoreheading
:END:
Reproducibility is the heart of the scientific method.

* TODO Getting Started with Python

** Installing Python
You can download the latest version of python at:
https://www.python.org/downloads/

#+DOWNLOADED: screenshot @ 2023-04-12 20:57:28
[[file:Getting_Started_with_Python/2023-04-12_20-57-28_screenshot.png]]


*** Python2 vs Python3                                               :B_note:
:PROPERTIES:
:BEAMER_env: note
:END:
Python code is usually backwards compatible with some exceptions.

The most major break between versions was the divsion between python2 and python3.

Some older projects require python2, however there is no legitmate reason to build
new projects using it.


*** Anaconda                                                         :B_note:
:PROPERTIES:
:BEAMER_env: note
:END:
Many in the scientific community use the Anaconda ecosystem.
Anconda bundles many useful applications for research but is beyond the scope
of this discussion.

*** Different Flavors of Python                                      :B_note:
:PROPERTIES:
:BEAMER_env: note
:END:
The most common varient of python is CPython, but other versions exist such as:
 - PyPy
 - Ironpython
 - Jython

Generally python code is compatible with all varients, but there might be
complications with more complex modules.

*** Follow the $PATH                                                 :B_note:
:PROPERTIES:
:BEAMER_env: note
:END:
When you run a command in the shell it looks up the location
of the program using the PATH environment variable.

Programs not in the PATH can't be found automatically by the shell,
which can cause headaches.



** Launching Python
After installing, python can be launched from the command line:

*** Windows                                                 :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
#+DOWNLOADED: screenshot @ 2023-04-12 21:43:49
[[file:Getting_Started_with_Python/2023-04-12_21-43-49_screenshot.png]]

*** Using the REPL
 1. enter a valid python command
 2. press enter / return
 3. the result is printed to next line of the console
 4. type exit() or CTRL-Z + return to quit

*** ipython                                                          :B_note:
:PROPERTIES:
:BEAMER_env: note
:END:
There are other python interpreters with my personal favorite being ipython.
Ipython has many quality of life improvements like magic methods, inline images,
pretty printing, and autocomplete.

While these improvements aren't strictly necessary, they can make your
life as a scientist much easier.


** Types and how things are represented
Built into python are a few representations of things.
These things are called *objects*, which can have different *types*
*** Common Types
 - Numeric:\\
   Integers, Floating Points, Complex Numbers
 - Sequence and mappings:\\
   Lists, Tuples, Strings, Dictionaries, Ranges
 - Functions:\\
   Code you want to reuse
 - Classes and objects:\\
   Bundles of code and data

** Numerics
Python has three built in ways of representing numbers:

*** Types of Built in Numbers                                :B_exampleblock:
:PROPERTIES:
:BEAMER_env: exampleblock
:END:
 1. Integers (int)
    - Whole numbers.
    - Infinite precision.
 2. Floating point (float)
    - Decimals (but in base 2)
    - precision limited by hardware.
 3. Complex number (complex)
    - exists on the complex plane.
    - has a real and an imaginary part.  
    - can have both float and int parts.
      
*** Numerical Bases and You                                          :B_note:
:PROPERTIES:
:BEAMER_env: note
:END:
People tend to count in decimal, a system using ten symbols (0-9) to represent numbers.
However this system is completely arbitrary.

People have counted in many diffent bases such as:
 - Binary (base 2)
 - Octal (base 8)
 - Duodecimal (base 12)
 - Hexidecimal (base 16)
 - Sexagesimal (base 60)

Each having its own distinct advantages and disadvantages.



** Precision, Accuracy, and Uncertainty
It can be tempting to think that computers are better at math than people.
*** Consider the following:                                         :B_block:
:PROPERTIES:
:BEAMER_env: block
:END:
Computers have a limited memory to represent numbers with.
\\
**** Code                                              :B_exampleblock:BMCOL:
:PROPERTIES:
:BEAMER_env: exampleblock
:BEAMER_col: 0.4
:END:

#+name: floating_point_error_demo
#+begin_src ipython :session i2sc :results output raw :exports code :noeval 
a = 1.2
b = 1.0

print(a - b)
#+end_src


**** What result do you expect?                               :B_block:BMCOL:
:PROPERTIES:
:BEAMER_env: block
:BEAMER_col: 0.45
:END:
 - A. 0.20000000000000000
 - B. @@beamer: {\color<2>[rgb]{0,0.6,0}@@0.19999999999999996@@beamer:}@@
 - C. 1.00000000000000001
 - D. 0.19000000000000005

*** Garbage in, garbage out!                                   :B_alertblock:
:PROPERTIES:
:BEAMER_env: alertblock
:END:
Remember to account for the uncertainty in your calculations or you'll end up with mysterious errors and useless data.



** Sequences and Collections
Sometimes, you need to store a bunch of things together:

*** List                                                          :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
A mutable (updatable) collection of objects.
#+begin_src ipython
example_list = ['a','b','c','d']
#+end_src

*** Tuple                                                         :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
A frozen (non-updatable) collection of objects.
#+begin_src ipython :noeval 
example_tuple = (1,2,3,4)
#+end_src

*** Dictonary                                                     :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
A collection of key, value pairs (mappings.)
#+begin_src ipython :noeval 
example_dict = {"key1": 123, "key2": "abc"}
#+end_src


*** Dictonaries and hashes                                           :B_note:
:PROPERTIES:
:BEAMER_env: note
:END:
Dictonary can only be made from hashable objects.

Hashing is a type of mathematical operation that takes an input
producing a unique output of a uniform size.

Hashing is an asymmetrical operation, meaing that it is very
difficult to figure out what made a specific hash.

Only frozen or unmutable objects can be hashed, because any change
creates a new hash.

Hashes have many uses including:
 - verifying file integrity
 - storing passwords safely
 - caching
 
** Strings

*** Computers store textual data as strings
Strings are a collection of symbols including:
 - letters
 - numbers
 - punctuation
 - control sequences
*** Beads
\begin{tikzpicture}
\draw[gray, thick] (-1,1) -- (5,1);
\end{tikzpicture}
** Classes and objects
To define a custom object, you use a class.
Classes allow you to bundle code and data as a single object.

*** Class                                                         :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
#+begin_src ipython
class ExampleClass:
    def __init__(self, args):
        self.args = args
        self.bar = "Hello World!!"

    def foo(self):
        print(self.bar)

example = ExampleClass("Hi")
#+end_src

*** endblock                                                :B_ignoreheading:
:PROPERTIES:
:BEAMER_env: ignoreheading
:END:
You can keep multiple independant copies of an object, allowing for
problems to be encapsulated and isolated. 



*** Inheritance                                                      :B_note:
:PROPERTIES:
:BEAMER_env: note
:END:
Objects can be based on other objects.

This allows for more complex functionality to be built on top
of simpler objects.


** Conditional Logic
The real power of programming comes from the ability to define
logical conditions.

*** What do you think?

#+begin_src ipython
name = input("What's your name? ")

if len(name) > 10:
    print("Wow that's a long name!")
elif len(name) <= 10 and len(name):
    print(f"Hi {name}!")
else:
    print("Sorry didn't catch that!")
#+end_src



** Truthyness and Booleans
Python uses the ~True~ and ~False~ objects to represent yes-no questions.
#+begin_src ipython :noeval 
(2 + 2 == 4) # True
(3 - 5 > 100) # False
#+end_src




** Reusing Code: Modules and Libraries
Modules allow you to share python programs and libraries and use them in your
projects.

*** Using modules                                      :B_exampleblock:BMCOL:
:PROPERTIES:
:BEAMER_env: exampleblock
:BEAMER_col: 0.5
:END:
#+begin_src ipython :noeval 
#import a module
import random
#import a specific submodule
from random import randint
#import all the submodules
from random import *
#+end_src



*** endblock                                                :B_ignoreheading:
:PROPERTIES:
:BEAMER_env: ignoreheading
:END:
By using modules you don't need to reinvent the wheel every time you want
to make something.

** Installing new Modules
To install a new module you use the command-line program ~pip~:
#+begin_src bash :noeval 
pip install numpy
pip uninstall numpy
#+end_src

*** Security Considerations                                          :B_note:
:PROPERTIES:
:BEAMER_env: note
:END:
Unforunately there are malicious actors out there that make evil modules.
Often times these are made to immitate a popular library like requests.

These modules when installed turn your project into a trojan horse,
and your computer is troy.

Make sure to verify that a package is what it says it is before using it.


*** Virtualenv and isolation                                         :B_note:
:PROPERTIES:
:BEAMER_env: note
:END:
Pip installs packages to a common location by default.
This often is desired, but sometimes programs will use incompatible versions
or break system tools.

To avoid this, it is recommended to set up a virtual environment (virtualenv)
and installing the packages there.

Tools such as ~pipx~ or ~pipenv~ can automate this for you.

** Common 3rd party libraries for science
 - Numpy:\\
   Handle large objects efficiently.
 - Scipy:\\
   A bunch of useful mathematical and scientific functions.
 - Sympy:\\
   Symbolic mathematics.
 - Pandas:\\
   Handle datasets with ease.
 - Matplotlib and Seaborn:\\
   Create graphs, charts, and figures.
 - Pint:\\
   Ensures your math takes units into account.



* TODO Conclusion

** Learning to program is hard, but you can do it.
Learning is a physical process that takes time and energy.
*** When you encounter trouble                                      :B_block:
:PROPERTIES:
:BEAMER_env: block
:END:
At somepoint, you *will* hit a metaphorical brick wall.
 - Take a break and re-evaluate the problem
   - What are you trying to do?
   - Are you asking the right question?
 - Double check your steps
   - Traceback messages are cryptic at first.
   - Learn to read them for invaluable feedback.
 - Try duck debugging!
   - Explain what you're working on to a rubber duck.
   - While silly it helps more often than not.
** Ask for help when you need it!
Your peers are your greatest resource for learning.
 - Use them!
*** Community Forums
Communities like [[https:stackoverflow.com][stackoverflow.com]] exist for asking and answering questions.
*** Before asking
A badly formed question is only going to frustrate you and your mentor.
 - What are you trying to do?
 - What is happening?
 - What steps have you tried?



** Embrace mistakes when learning
You will make mistakes, that's part of the learning process.

*** Fail fast; fail often

**** List                                                             :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.5
:END:
 - Don't be afraid of being wrong!
 - Iterate on your previous work!
 - Keep it simple sweetie!
 - Document your progress!
 - How do others approch this?
 - Build tests to verify your results!

**** Figure                                                           :BMCOL:
:PROPERTIES:
:BEAMER_col: 0.5
:END:
#+begin_src ipython :session i2sc :ipyfile ./media/images/faround.png :results raw :exports results :cache yes 
with plt.xkcd():
    fig = plt.figure()
    ax = fig.add_axes((0, 0, 1, 1))
    ax.set_xticks([])
    ax.set_yticks([])
    ax.spines[['top', 'right']].set_visible(False)
    ax.set_xlabel("Screw around")
    ax.set_ylabel("Find out")

    
    ax.annotate(
        'HOW MUCH YOU LEARN!',
        xy=(5, 5), arrowprops=dict(arrowstyle='->'), xytext=(5, 4))

    

    ax.plot(range(10))

     
    plt.show()
#+end_src

#+RESULTS[dda27abd3b7e5c5fb09de8f6878e1e2015f243cf]:
[[file:./media/images/faround.png]]



** Still not convinced?
This presentation was prepared using the techniques discussed.
*** Tools used                                               :B_exampleblock:
:PROPERTIES:
:BEAMER_env: exampleblock
:END:
 - emacs
   - orgmode
   - org-ref
 - latex
   - bibtex
   - beamer
   - tikz
 - python
   - matplotlib
     
*** Source
You can find the source document here:
https://github.com/Nalisarc/intro-to-scripting

** Summary
Computers are powerful tools that can greatly improve your
work as a scientist.

* Addendium                               

** TODO Bibliography
[[bibliography:../bibliography/references.bib]]
[[bibliographystyle:amsplain]]
** Prompt for questions
#+begin_center
Follow up questions can be sent to:
nalisarc@gmail.com
#+end_center
** TODO Further Reading

 - https://youtu.be/dQhj5RGtag0
** 
* Links                                                            :noexport:

[[id:24586-3012-4104-b65b-bf2a2e526a18][Roam Index]]

[[id:da153c54-5934-4b5b-90c0-9b7e0dab9cd9][Python]]

[[id:c1622e03-0f6e-47d4-be82-8eea88c4dc3f][Matplotlib]]:
 - https://matplotlib.org/stable/users/index.html
 - https://matplotlib.org/stable/tutorials/index.html
 - https://matplotlib.org/stable/plot_types/index.html
 - https://matplotlib.org/stable/api/index.html

[[id:6550f037-b51e-4e62-bbab-e1874c23ba5e][numpy]]

[[id:a624a7ff-29e5-4796-93ec-a271fee0acb4][Pandas]]


   https://www.aruplab.com/magnify23/sanguine-new-data-visualization-tool-predicts-transfusion-needs

[[id:9b0f7c69-04be-4aef-9ccc-f83f9294c91c][Bioinformatics Data Skills (Vince Buffalo)]]

[[id:0c64f7dd-7999-46d6-a538-9e31da3a6541][ModelingAndSimulationInPython]]

[[id:163a9579-1301-4e9d-a388-73b9ffe71ced][Scipy]]

https://orgmode.org/worg/exporters/beamer/tutorial.html
https://texdoc.org/serve/beamer/0
https://en.wikipedia.org/wiki/List_of_programming_languages

https://nigms.nih.gov/education/Inside-Life-Science/Pages/Genetics-by-the-Numbers.aspx

https://med.stanford.edu/news/all-news/2022/01/dna-sequencing-technique.html

https://pbs.twimg.com/media/FspnKDKaEAACpQi?format=jpg&name=small

https://chartio.com/learn/business-intelligence/5-data-visualization-best-practices/

* C code for summation                                             :noexport:

#+begin_src C :tangle ~/sum.c 
#include <stdio.h>

int main()
{
   int n, sum = 0, c, array[100];

   scanf("%d", &n);

   for (c = 0; c < n; c++)
   {
      scanf("%d", &array[c]);
      sum = sum + array[c];
   }

   printf("Sum = %d\n", sum);

   return 0;
}
#+end_src
